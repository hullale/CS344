#!/bin/bash
########## Global Variables ############
awk_transpose='{
    for ( i=1; i <= NF; i++ )
        row[i] = row[i]((row[i])?" ":"")$i
}

END{
    for ( x = 1; x <= length(row) ; x++ )
        print row[x]
}'

awk_proper_rounding='
    {printf("%d\n",$1 + 0.5)}
'

master_pid=$!

########## Functions ###########
show_usage_error ()
{
    echo "Usage: stats {-rows|-cols} [file]" >&2
    exit 1
}

show_empty_file_error ()
{
    echo "stats: Input empty. Please provide valid input." >&2
    exit 1
}

show_invalid_file_error ()
{
    echo "stats: Cannot read file. Please verify file exists or check permissions." >&2
    exit 1
}

remove_temp_if_exist ()
{
    rm -f ${master_pid}"_"transposed
    rm -f ${master_pid}"_"temp
}

handle_unexpected_termination_error ()
{
    remove_temp_if_exist
    echo "CTRL+C received. Exiting." >&2
    exit 1
}


#####################################################
#####################################################
########## "stats" script "main"-ish code ###########

# Handle unexpected termination
trap handle_unexpected_termination_error INT HUP TERM

# Determine if we're getting data from stdin or a file, error if neither
if [ $# -eq 0 ] || [ $# -gt 2 ]; then
    # No arguments or incorrect, throw an error
    show_usage_error
elif [ $# -eq 1 ]; then
    is_stdin=1
elif [ $# -eq 2 ]; then
    is_stdin=0
fi

# Determine if we're doing statistics based on columns or rows, error if neither
if [[ $1 == -r* ]]; then
    is_rows=1
elif [[ $1 == -c* ]]; then
    is_rows=0
else
    show_usage_error
fi

# If the input is a file, make sure we can open it and that it exists
# Also, we assign the file to file descriptor 3 for use with read later
if [ ${is_stdin} -eq 0 ]; then
    if [ ! -e $2 ] || [ ! -r $2 ] || [ ! -f $2 ]; then
        show_invalid_file_error
    fi
fi

# If stats should be on columns, translate table so the columns are the new rows and rows are the new columns
# This will make it so the same stats math can be used to generate the correct data
if [ ${is_rows} -eq 0 ] && [ ${is_stdin} -eq 0 ]; then
    cat $2 | awk "${awk_transpose}" > ${master_pid}"_"transposed
    exec 3<> ${master_pid}"_"transposed
elif [ ${is_rows} -eq 0 ] && [ ${is_stdin} -eq 1 ]; then
    line_count=0
    while read current_line
    do
        echo -e ${current_line} >> ${master_pid}"_"temp
        ((line_count = line_count + 1))
    done

    if [ ${line_count} -eq 0 ]; then
        show_empty_file_error
    fi

    cat ${master_pid}"_"temp | awk "${awk_transpose}" > ${master_pid}"_"transposed
    exec 3<> ${master_pid}"_"transposed
    is_stdin=0

elif [ ${is_rows} -eq 1 ] && [ ${is_stdin} -eq 0 ]; then
    exec 3<> $2
fi

# Now we perform the stats math operations on the data
line_count=0
declare -a averages
declare -a medians

while [ 1 ];
do
    if [ ${is_stdin} -eq 1 ]; then
        read current_line
    else
        read -u 3 current_line
    fi

    read_result=$?

    if [ ${read_result} -eq 1 ] && [ ${line_count} -eq 0 ]; then
        show_empty_file_error
    elif [ ${read_result} -eq 1 ]; then
        break
    fi

    sum=0
    count=0
    avg=0
    newline="\n"
    numbers_string=""

    # This part does the summing and averaging, and adds the numbers to a new string so it can be parsed by sort
    for word in ${current_line}
    do
        numbers_string=${numbers_string}${newline}${word}
        ((sum = word + sum))
        ((count = count + 1))
    done

    avg=$(echo "(${sum}/${count})" | bc -l | awk "${awk_proper_rounding}")
    averages[${line_count}]=${avg}

    # Now the new string we created is sorted numerically
    sorted=$(echo -e ${numbers_string} | sort -n)

    # Then we add the median number to our medians array
    i=0
    for word in ${sorted}
    do
        if [ ${i} == $(((count/2))) ]; then
            medians[${line_count}]=${word}
            break
        fi
        ((i = i + 1))
    done
    ((line_count = line_count + 1))

done

# Pretty printing for rows calculations
if [ ${is_rows} -eq 1 ]; then
    echo -e "Average\tMedian"

    count=0
    for word in ${averages[*]}
    do
        echo -e "${averages[count]}\t${medians[count]}"
        ((count = count + 1))
    done
# Pretty printing for columns calculations
else
    echo -e "Averages:"
    first=1
    for word in ${averages[*]}
    do
        if [ ${first} -eq 1 ]; then
            echo -e -n "${word}"
            first=0
        else
            echo -e -n "\t${word}"
        fi
        ((count = count + 1))
    done
    echo

    echo -e "Median:"
    first=1
    for word in ${medians[*]}
    do
        if [ ${first} -eq 1 ]; then
            echo -e -n "${word}"
            first=0
        else
            echo -e -n "\t${word}"
        fi
        ((count = count + 1))
    done
    echo
fi

remove_temp_if_exist
exit 0